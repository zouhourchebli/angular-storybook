"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
exports.isLineBlank = function (line) {
    return line.length === 0 || !(/\S/.test(line));
};
/**
 * Tests whether the previous line is the class declaration
 */
exports.isPreviousLineClassDec = function (node, sourceFile) {
    var prevLine = _this.getPrevLinesText(node, sourceFile);
    return /\b(class|implements|extends)\b\s+[A-Za-z0-9]+/.test(prevLine);
};
/**
 * Tests whether the previous line is the opening brace
 */
exports.isPrevLineOpeningBrace = function (node, sourceFile) {
    var prevLine = exports.getPrevLinesText(node, sourceFile);
    return /^((\s*{\s*)|([\w\s,<]*\>\s*{\s*))$/.test(prevLine);
};
/**
 * Tests whether method is within a class (as opposed to within an object literal)
 */
exports.isClassMethod = function (node) {
    var parentType = node.parent && node.parent.kind;
    return parentType === ts.SyntaxKind.ClassDeclaration;
};
/**
 * Gets the text content of a line above the method
 * Any documenting comments are ignored and we start from the first line above those
 * If lineIndex is passed, it will get the text of the nth line above the method
 */
exports.getPrevLinesText = function (node, sourceFile, lineIndex) {
    if (lineIndex === void 0) { lineIndex = 1; }
    return sourceFile.text.substring(exports.getNodeLineStart(node, sourceFile, lineIndex + 1), exports.getNodeLineStart(node, sourceFile, lineIndex) - 1);
};
/**
 * Gets position of start of line containing node
 */
exports.getNodeLineStart = function (node, sourceFile, lineIndex) {
    if (lineIndex === void 0) { lineIndex = 1; }
    var pos = node.getStart();
    var comments = ts.getLeadingCommentRanges(sourceFile.text, node.pos) || [];
    if (comments.length > 0) {
        pos = comments[0].pos;
    }
    var lineStartPositions = sourceFile.getLineStarts();
    var startPosIdx = lineStartPositions.findIndex(function (startPos, idx) {
        return startPos > pos || idx === lineStartPositions.length - 1;
    }) - lineIndex;
    return lineStartPositions[startPosIdx];
};
/**
 * Calculates difference in actual numbers of lines above node and number set in options
 */
exports.getLineDifference = function (node, sourceFile, options) {
    var difference = 0;
    if (options.length > 0) {
        // if user has specified the number of new lines they want between their methods
        // we need to check there are exactly that many blank lines
        var numLinesOption = options[0];
        // check for invalid num lines option
        if (!/^[0-9]+$/.test(numLinesOption)) {
            return 1;
        }
        // check each previous line is blank for num lines specified
        var i = void 0;
        for (i = 0; i < numLinesOption; i++) {
            if (!exports.isLineBlank(exports.getPrevLinesText(node, sourceFile, i + 1))) {
                difference = numLinesOption - i;
                return difference;
            }
        }
        // then check that the line before is NOT blank
        // we count how many lines it takes to get to a non-blank one so we can fix properly
        var lineBlank = exports.isLineBlank(exports.getPrevLinesText(node, sourceFile, i + 1));
        if (lineBlank) {
            while (lineBlank) {
                i++;
                difference--;
                lineBlank = exports.isLineBlank(exports.getPrevLinesText(node, sourceFile, i + 1));
            }
            return difference;
        }
        return difference;
    }
    else {
        // if user has not specified the number of blank lines, we just want to check there
        // is at least one
        return exports.isLineBlank(exports.getPrevLinesText(node, sourceFile)) ? 0 : 1;
    }
};
