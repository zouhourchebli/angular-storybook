"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lint = require("tslint");
var ts = require("typescript");
var utils_1 = require("./utils");
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new LinesBetweenClassMembersWalker(sourceFile, this.getOptions()));
    };
    Rule.metadata = {
        ruleName: 'lines-between-class-members',
        type: 'style',
        description: 'Forces all classes to have at least one, or an exact number of, lines between class members',
        options: 'boolean',
        optionsDescription: 'Exact number of lines that should be between class members',
        rationale: 'Ensures consistency between classes',
        typescriptOnly: true,
    };
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
var LinesBetweenClassMembersWalker = /** @class */ (function (_super) {
    __extends(LinesBetweenClassMembersWalker, _super);
    function LinesBetweenClassMembersWalker(sourceFile, options) {
        var _this = _super.call(this, sourceFile, options) || this;
        _this.difference = 0;
        return _this;
    }
    LinesBetweenClassMembersWalker.prototype.visitConstructorDeclaration = function (node) {
        this.validate(node);
        // call the base version of this visitor to actually parse this node
        _super.prototype.visitConstructorDeclaration.call(this, node);
    };
    LinesBetweenClassMembersWalker.prototype.visitMethodDeclaration = function (node) {
        this.validate(node);
        // call the base version of this visitor to actually parse this node
        _super.prototype.visitMethodDeclaration.call(this, node);
    };
    LinesBetweenClassMembersWalker.prototype.validate = function (node) {
        /* Calculate difference between lines above class member and desired lines */
        this.difference = utils_1.getLineDifference(node, this.getSourceFile(), this.getOptions());
        /* Ignore method immediately following class declaration */
        var prevLineClassDec = utils_1.isPreviousLineClassDec(node, this.getSourceFile());
        var prevLineOpeningBrace = utils_1.isPrevLineOpeningBrace(node, this.getSourceFile());
        /* Ignore methods inside object literals */
        var classMethod = utils_1.isClassMethod(node);
        if (this.difference !== 0 && !prevLineClassDec && !prevLineOpeningBrace && classMethod) {
            this.onRuleLintFail(node);
        }
    };
    LinesBetweenClassMembersWalker.prototype.onRuleLintFail = function (node) {
        var start = node.getStart();
        var width = node.getWidth();
        var text = node.getText();
        var comments = ts.getLeadingCommentRanges(this.getSourceFile().text, node.pos) || [];
        if (comments.length > 0) {
            start = comments[0].pos;
            width = comments[0].end - start;
            text = this.getSourceFile().text.substr(start, width);
        }
        var errorMessage;
        var replacement;
        var fix;
        var options = this.getOptions();
        var numLinesOption = options[0];
        var sourceFile = this.getSourceFile();
        // find whitespace identation of current line, node start is start of text but any
        // identation needs to be calculated here
        var whitespace = '';
        var lineStart = utils_1.getNodeLineStart(node, sourceFile);
        if (lineStart !== start) {
            whitespace = Array(start - lineStart).fill(' ').join('');
            width += start - lineStart;
            start = lineStart;
        }
        if (numLinesOption == null) {
            errorMessage = 'must have at least one new line between class methods';
            replacement = new Lint.Replacement(start, width, "\n" + whitespace + text);
        }
        else if (!/^[0-9]+$/.test(numLinesOption)) {
            errorMessage = "invalid value provided for num lines configuration - " + numLinesOption + ", see docs for how to configure";
        }
        else {
            errorMessage = "must have " + numLinesOption + " new line(s) between class methods";
            if (this.difference > 0) {
                // not enough new lines add some more
                var newLines = Array(this.difference).fill('\n').join('');
                replacement = new Lint.Replacement(start, width, "" + newLines + whitespace + text);
            }
            else if (this.difference < 0) {
                // too many lines delete some
                var lineStartPositions_1 = this.getSourceFile().getLineStarts();
                var startPosIdx = lineStartPositions_1.findIndex(function (startPos, idx) {
                    return startPos > start || idx === lineStartPositions_1.length - 1;
                }) - 1;
                start = lineStartPositions_1[startPosIdx + this.difference];
                width += lineStartPositions_1[startPosIdx] - start;
                replacement = new Lint.Replacement(start, width, "" + whitespace + text);
            }
        }
        if (replacement) {
            // handle both tslint v4 & v5
            if (typeof Lint['Fix'] === 'undefined') {
                fix = replacement;
            }
            else {
                fix = new Lint['Fix']('lines-between-class-members', [replacement]);
            }
        }
        this.addFailure(this.createFailure(start, width, errorMessage, fix));
    };
    return LinesBetweenClassMembersWalker;
}(Lint.RuleWalker));
